# 13 - Address Spaces:
---

## The early Days:
- One process running at a time and only the OS and that one program in memory
![[Pasted image 20240209094148.png]]

## Multiprogramming and Time Sharing:
- Multiple programs running to increase the utilization of CPU
Leaving processes in memory while switching between processes. (time sharing) 
==Increases interactivity==
![[Pasted image 20240209094632.png]]

allowing multiple programs to reside concurrently in memory makes ==protection an important issue==; you don’t want a process to be able to ==read==, or worse, ==write== some other process’s memory.

## The Address Space:

==address space==: an easy to use abstraction of physical memory.
![[Pasted image 20240209095000.png]]
==Program Code==: code of the program (the instructions)
==heap== is used for dynamically-allocated, user-managed memory

The program Code is static so it is placed at the top and know that it won’t need any more space as the program runs.

the OS, in tandem with some hardware support, will translate the virtual memory address 0x00 as 320KB to physical memory address (where the program starts).

## Goals of VM (Virtual Memory):
1. ==transparency==: The OS should implement virtual memory in a way that is invisible to the running program. (program shouldn't be aware that memory is virtualized)
2. ==efficiency==: The OS should strive to make the virtualization as efficient as possible, both in terms of time (i.e., not making programs run much more slowly) and space (i.e., not using too much memory for structures needed to support virtualization).
3. ==protection==: he OS should make sure to protect processes from one another as well as the OS itself from processes. Protection thus enables us to deliver the property of ==isolation== among processes; each process should be running in its own isolated co- coon, safe from the ravages of other faulty or even malicious processes.

# 14 - Memory API:
---
Dynamically allocating strings in C:
- `malloc(strlen(s) + 1)`, which gets the length of the string using the function strlen(), and adds 1 to it in order to make room for the end-of-string character. Using sizeof() may lead to trouble here.

Allocating a type double example:
`double *d = (double *) malloc(sizeof(double));`

## Not Allocating Enough Memory:
Proper Code:
```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src); // work properly
```

Not allocating enough memory for a string type:
```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src)); // too small!
strcpy(dst, src); // work properly
```

## Underlying OS Support:
`malloc()` and `free()` aren't system calls but ==Library calls==. 

`malloc` library manages space within your ==virtual address space==, but itself is built on top of some system calls which call into the OS to ask for more memory or release some back to the system.

## Other calls:
`calloc()` allocates memory and also zeroes it before returning; this prevents some errors where you assume that memory is zeroed and forget to initialize it yourself

`realloc()` makes a new larger region of memory, copies the old region into it, and returns the pointer to the new region.

# 15 - Address Translation:
---
==Efficiency== and ==control== together are two of the main goals of any modern operating system.

## Address Translation:
Also known as `hardware-based address translation`. 

With address translation, the hardware transforms each memory access (e.g., an instruction fetch, load, or store), changing the ==virtual== address provided by the instruction to a ==physical== address where the desired information is actually located.

address translation is ==performed by the hardware== to redirect application memory references to their actual locations in memory.

THE OS MUST ==manage memory== by keeping track of which locations are free and which are in use, and judiciously intervening to maintain control over how memory is used.

EXAMPLE:
Program in C
```c
void func() {
    int x;
    x = x + 3; // this is the line of code we are interested in
```

Same program in x86 ASM:
```asm 
128: movl 0x0(%ebx), %eax ;load 0+ebx into eax
132: addl $0x03, %eax ;add 3 to eax register
135: movl %eax, 0x0(%ebx) ;store eax back to mem
```

Whats happening on Virtual memory
![[Pasted image 20240209130514.png]]

## dynamic relocation:
(Also known as ==base and bounds==)

Two registers within each CPU:
1. The base register (start of process in physical memory)
2. The bound (limit) register (where to cut off)
the bounds register is there to help with ==protection==.

Any memory reference is generated by the process, it is ==translated== by the processor in the following manner:
`physical address = virtual address + base`

If a process generates a virtual address that is greater than the bounds, or one that is negative, the CPU will raise an exception, and the process will likely be terminated.

Sometimes people call the part of the processor that helps with address translation the ==memory management unit (MMU)==

![[Pasted image 20240211093054.png]]

## A Summary:
The OS runs in privileged mode (or ==kernel mode==), where it has access to the entire machine; applications run in ==user mode==, where they are limited in what they can do.
each CPU thus has an additional pair of registers, part of the memory ==management unit (MMU)== of the CPU.
only in ==kernel (or privileged) mode== can the registers be modified.
![[Pasted image 20240211093553.png]]

# 16 - Segmentation:
---
There is a big chunk of ==“free”== space right in the middle, between the stack and the heap.
the simple approach of using a base and bounds register pair to virtualize memory is ==wasteful==.

## Segmentation: Generalized Base/Bounds:
why not have a base and bounds pair ==per logical segment== of the address space?
![[Pasted image 20240211094037.png]]
What segmentation allows the OS to do is to ==place each one of those segments in different parts of physical memory==, and thus avoid filling physical memory with unused virtual address space.

ONLY USED MEMORY IS ALLOCATED IN PHYSICAL MEMORY
![[Pasted image 20240211094637.png]]

The ==MMU== must support 3 base bound registers
![[Pasted image 20240211094820.png]]

## Which Segment Are We Referring To?:
![[Pasted image 20240211095712.png]]
- Top two bits (`01`) tell the hardware ==which segment== we are referring to.
- The bottom 12 bits are the ==offset into the segment==: `0000 0110 1000`, or hex `0x068`, or 104 in decimal.
By ==adding the base register to the offset==, the hardware arrives at the final ==physical== address.

How it checks:
```c
// get top 2 bits of 14-bit VA
Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT
// now get offset
Offset  = VirtualAddress & OFFSET_MASK
if (Offset >= Bounds[Segment])
    RaiseException(PROTECTION_FAULT)
else
    PhysAddr = Base[Segment] + Offset
    Register = AccessMemory(PhysAddr)
```

## The Stack is weird:
==translation must proceed differently==
In physical memory, it starts at 28KB and ==grows back== to 26KB, corresponding to virtual addresses 16KB to 14KB.
![[Pasted image 20240211094637.png]]

The hardware also ==needs to know which way the segment grows== (a bit, for example, that is set to 1 when the segment grows in the positive direction, and 0 for negative)
![[Pasted image 20240211100231.png]]

## Support for sharing:
Sharing certain memory segments between address spaces is ==useful to save memory==.
==code sharing== is common and still in use in systems today.
![[Pasted image 20240211100503.png]]

## Fine-grained vs. Coarse-grained Segmentation:
A few segments (i.e., code, stack, heap) this segmentation as ==coarse-grained==, it chops up the address space into relatively large, coarse chunks.
Some early systems used a large number of smaller segments, referred to as ==fine-grained== segmentation.

## OS Support:
==external fragmentation==: physical memory quickly becomes full of little holes of free space, making it difficult to allocate new segments, or to grow existing ones.

==compact== physical memory by rearranging the existing segments.
![[Pasted image 20240211101043.png]]